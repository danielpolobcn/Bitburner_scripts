/** @param {NS} ns */
export async function main(ns) {

// ARGUMENTS TO PASS: 1) Maximum nodes to buy, 2) Delay before next attempted purchase, in seconds.
// If no arguments are passed, the default values are 12 nodes and 10 seconds.
const MaxNodes = ns.args[0] || 12; 
const Delay = 1000 * ns.args[1] || 10000;
ns.tprint("Maximum nodes to purchase: " , MaxNodes);
ns.tprint("Delay before next purchase: " , Delay / 1000 , " seconds");

// Function required to assess the production of each node, both current or with the next possible upgrades.
function GetStats(node , type) {
	let level = ns.hacknet.getNodeStats(node).level;
	let ram = ns.hacknet.getNodeStats(node).ram;
	let cores = ns.hacknet.getNodeStats(node).cores;
	switch (type) {
		case 0:
			level++;
			break;
		case 1:
			ram++;
			break;
		case 2:
			cores++;
			break;
	}
	// The formula for the income generated by every type of upgrade has been extracted from the source code.
	let income = ns.getHacknetMultipliers().production * ((level * 1.5) * Math.pow(1.035, ram - 1) * ((cores + 5) / 6));
	return income;
}

// Functions to estimate and identify the most profitable upgrade for every current node.
function BestUpgradeProfit(node) {
	let Profit = [];
	Profit[0] = (GetStats(node , 0) - GetStats(node)) / ns.hacknet.getLevelUpgradeCost(node);
	Profit[1] = (GetStats(node , 1) - GetStats(node)) / ns.hacknet.getRamUpgradeCost(node);
	Profit[2] = (GetStats(node , 2) - GetStats(node)) / ns.hacknet.getCoreUpgradeCost(node);
	return Math.max.apply(null , Profit);
}

function BestUpgradeType(node) {
	let Profit = [];
	Profit[0] = (GetStats(node , 0) - GetStats(node)) / ns.hacknet.getLevelUpgradeCost(node);
	Profit[1] = (GetStats(node , 1) - GetStats(node)) / ns.hacknet.getRamUpgradeCost(node);
	Profit[2] = (GetStats(node , 2) - GetStats(node)) / ns.hacknet.getCoreUpgradeCost(node);
	return Profit.indexOf(Math.max.apply(null , Profit));
}

// Loop to purchase upgrades or new nodes by expected profitability, up to the indicated maximum number of nodes to purchase.
let Nodes = 0;
let AllBestProfits = [];
let Money = 0;
let NodeCost = 0;
let NewNodeProfit = 0;
let NodeId = 0;
let Type = 0;
while (true) {
	Nodes = (ns.hacknet.numNodes());
	if (Nodes === MaxNodes) {
		break;
	}
	for (NodeId = 0 ; NodeId < Nodes ; NodeId++) {
		AllBestProfits[NodeId] = BestUpgradeProfit(NodeId);
	}
	Money = ns.getServerMoneyAvailable("home");
	NodeCost = ns.hacknet.getPurchaseNodeCost();
	NewNodeProfit = ((ns.getHacknetMultipliers().production * 1.5) / NodeCost);
	if (Math.max.apply(null , AllBestProfits) < NewNodeProfit && NodeCost < (Money / 10)) {
		ns.hacknet.purchaseNode();
	}
	else {
		NodeId = AllBestProfits.indexOf(Math.max.apply(null , AllBestProfits));
		Type = BestUpgradeType(NodeId);
		if (Type == 0) {
			if (ns.hacknet.getLevelUpgradeCost(NodeId) < (Money / 10)) {
				ns.hacknet.upgradeLevel(NodeId , 1);
			}
		}
		if (Type == 1) {
			if (ns.hacknet.getRamUpgradeCost(NodeId) < (Money / 10)) {
				ns.hacknet.upgradeRam(NodeId , 1);
			}
		}
		if (Type == 2) {
			if (ns.hacknet.getCoreUpgradeCost(NodeId) < (Money / 10)) {
				ns.hacknet.upgradeCore(NodeId , 1);
			}
		}
	}
	await ns.sleep(Delay);
}

// The former loop is repeated, with the option to buy new nodes removed, to finish upgrading all the current nodes.
while (true) {
	Nodes = (ns.hacknet.numNodes());
	for (NodeId = 0 ; NodeId < Nodes ; NodeId++) {
		AllBestProfits[NodeId] = BestUpgradeProfit(NodeId);
	}
	Money = ns.getServerMoneyAvailable("home");
	NodeId = AllBestProfits.indexOf(Math.max.apply(null , AllBestProfits));
	Type = BestUpgradeType(NodeId);
	if (Type == 0) {
		if (ns.hacknet.getLevelUpgradeCost(NodeId) < (Money / 10)) {
			ns.hacknet.upgradeLevel(NodeId , 1);
		}
	}
	if (Type == 1) {
		if (ns.hacknet.getRamUpgradeCost(NodeId) < (Money / 10)) {
			ns.hacknet.upgradeRam(NodeId , 1);
		}
	}
	if (Type == 2) {
		if (ns.hacknet.getCoreUpgradeCost(NodeId) < (Money / 10)) {
			ns.hacknet.upgradeCore(NodeId , 1);
		}
	}
	await ns.sleep(Delay);
}

}
